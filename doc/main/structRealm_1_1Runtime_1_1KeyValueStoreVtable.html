<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Realm: Realm::Runtime::KeyValueStoreVtable Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<!-- BEGIN version select -->
<link rel="stylesheet" type="text/css" href="../dropdown.css">
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js">
</script>
<!-- END version select -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Realm
   <!-- BEGIN version select -->
    <br />
    <div class="dropdown">
     <button class="dropbtn">Version 25.6.1-rc.4+ff9dc203</button>
     <div class="dropdown-content"></div>
    </div>
    <script type="text/javascript" src="../selectversion.js"></script>
   <!-- END version select -->
   </div>
   <div id="projectbrief">A distributed, event-based tasking library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structRealm_1_1Runtime_1_1KeyValueStoreVtable.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structRealm_1_1Runtime_1_1KeyValueStoreVtable-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Realm::Runtime::KeyValueStoreVtable Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="runtime_8h_source.html">runtime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8a4e9695f41060b9cae73c3366cb95f9" id="r_a8a4e9695f41060b9cae73c3366cb95f9"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a></td></tr>
<tr class="separator:a8a4e9695f41060b9cae73c3366cb95f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5436fe9fcf2f38b0908cd07327d59f" id="r_ace5436fe9fcf2f38b0908cd07327d59f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a></td></tr>
<tr class="separator:ace5436fe9fcf2f38b0908cd07327d59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad664af62bb1e06c6c421f2969545c056" id="r_ad664af62bb1e06c6c421f2969545c056"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ad664af62bb1e06c6c421f2969545c056">put</a> )(const void *key, size_t key_size, const void *value, size_t value_sizem, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td></tr>
<tr class="separator:ad664af62bb1e06c6c421f2969545c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749da02cd4a0986815daec923541aa27" id="r_a749da02cd4a0986815daec923541aa27"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a749da02cd4a0986815daec923541aa27">get</a> )(const void *key, size_t key_size, void *value, size_t *value_size, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td></tr>
<tr class="separator:a749da02cd4a0986815daec923541aa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8592a72ec9641bf3cb27c1eb23c98a" id="r_a0d8592a72ec9641bf3cb27c1eb23c98a"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a0d8592a72ec9641bf3cb27c1eb23c98a">bar</a> )(const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td></tr>
<tr class="separator:a0d8592a72ec9641bf3cb27c1eb23c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12572f75a8f7a9a13611743fe86123" id="r_a5a12572f75a8f7a9a13611743fe86123"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a5a12572f75a8f7a9a13611743fe86123">cas</a> )(const void *key, size_t key_size, void *expected, size_t *expected_size, const void *desired, size_t desired_size, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td></tr>
<tr class="separator:a5a12572f75a8f7a9a13611743fe86123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acb6e2c5b5a0a1f758bbaa9bdb84899a1" id="r_acb6e2c5b5a0a1f758bbaa9bdb84899a1"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#acb6e2c5b5a0a1f758bbaa9bdb84899a1">group_key</a> = &quot;realm_group&quot;</td></tr>
<tr class="separator:acb6e2c5b5a0a1f758bbaa9bdb84899a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0053107b8cf9112c41cc6abad25860" id="r_a3b0053107b8cf9112c41cc6abad25860"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a3b0053107b8cf9112c41cc6abad25860">rank_key</a> = &quot;realm_rank&quot;</td></tr>
<tr class="separator:a3b0053107b8cf9112c41cc6abad25860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951c0d5d552550848f57bd0cedcc638d" id="r_a951c0d5d552550848f57bd0cedcc638d"><td class="memItemLeft" align="right" valign="top">static constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a951c0d5d552550848f57bd0cedcc638d">ranks_key</a> = &quot;realm_ranks&quot;</td></tr>
<tr class="separator:a951c0d5d552550848f57bd0cedcc638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Some networks prefer to bootstrap via callbacks using a vtable A client provides an implementation of the functions in the vtable and <a class="el" href="namespaceRealm.html">Realm</a> will invoke them as part of bootstrapping the network and providing support for elasticity (when networks support it). Some functions are required while others are either/or options. All callbacks will either be performed in an external thread (one not made by <a class="el" href="namespaceRealm.html">Realm</a> but has called into <a class="el" href="namespaceRealm.html">Realm</a>) or by a designated <a class="el" href="namespaceRealm.html">Realm</a> thread independent of <a class="el" href="namespaceRealm.html">Realm</a>'s background worker threads so that clients can use non-Realm synchronization primitives in the implementation of these functions and not need to worry about blocking or impacting forward progress. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a0d8592a72ec9641bf3cb27c1eb23c98a" name="a0d8592a72ec9641bf3cb27c1eb23c98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8592a72ec9641bf3cb27c1eb23c98a">&#9670;&#160;</a></span>bar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* Realm::Runtime::KeyValueStoreVtable::bar) (const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a12572f75a8f7a9a13611743fe86123" name="a5a12572f75a8f7a9a13611743fe86123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a12572f75a8f7a9a13611743fe86123">&#9670;&#160;</a></span>cas</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* Realm::Runtime::KeyValueStoreVtable::cas) (const void *key, size_t key_size, void *expected, size_t *expected_size, const void *desired, size_t desired_size, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "cas" function should be provided in cases of elastic bootstrap when an arbitrary number of processes can join or leave the <a class="el" href="namespaceRealm.html">Realm</a> during its execution. The cas function should perform an atomic compare-and-swap operation on a key by checking that the key matches a particular value and if it does then updating it with the desired value in a single atomic operation. If the key does not yet exist then the transaction should create the key with the desirecd value. If the value associated with the key does not match the expected result, the call should fail, but return the updated expected value and size as long as it is less than or equal to the original expected size. If the new value size is larger than the expected size, then only the expected_size should be updated. It is possible for this call to fail and for the bootstrap to continue, although a large number of repetitive failures will likely lead to a timeout. </p>

</div>
</div>
<a id="a749da02cd4a0986815daec923541aa27" name="a749da02cd4a0986815daec923541aa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749da02cd4a0986815daec923541aa27">&#9670;&#160;</a></span>get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* Realm::Runtime::KeyValueStoreVtable::get) (const void *key, size_t key_size, void *value, size_t *value_size, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "get" function must retrieve the value associated with the given key if it can be found. <a class="el" href="namespaceRealm.html">Realm</a> will call this function with the value buffer already allocated with the value_size populated with the maximum size of the value that can be returned. If the key is found and the value size is less than or equal to the value_size passed in by <a class="el" href="namespaceRealm.html">Realm</a>, then the value buffer should be populated and the value_size updated with the actual size of the value found. If the key is found but the resulting value is larger than the buffer size, then the function should update value_size with the actual size of the buffer but does not need to populate the value buffer (sinze it obviously will not fit). If the key cannot be found then the value size should be set to zero. The function should always return true as long as the get call works correctly (even if a key is not found or the buffer is not larger enough). Returning false should only occur if the function call fails in some way that makes it impossible to know if the key exists or not. If the callback fails then the network initialization might not succeed. </p>

</div>
</div>
<a id="acb6e2c5b5a0a1f758bbaa9bdb84899a1" name="acb6e2c5b5a0a1f758bbaa9bdb84899a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6e2c5b5a0a1f758bbaa9bdb84899a1">&#9670;&#160;</a></span>group_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view Realm::Runtime::KeyValueStoreVtable::group_key = &quot;realm_group&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The "bar" function should be provided in cases where processes are joining and leaving the <a class="el" href="namespaceRealm.html">Realm</a> as a group. It must perform a barrier across all the processes in the (implicit) group that this process is a part of along with flushing any puts done before it. It should return true if the barrier succeeds and false if it fails. If the barrier fails then it can be expected the <a class="el" href="namespaceRealm.html">Realm</a> bootstrap will also fail. If you provide a bar method, then you must also provide support in the "get" method for three special keys:</p><ul>
<li>"realm_group": the value associated with this key must be interpretable as an integer that is the same for all processes that cooperate in this barrier. It must be distinct from any other group identifier for other processes that are joining the same <a class="el" href="namespaceRealm.html">Realm</a>.</li>
<li>"realm_ranks": the value associated with this key must be interpretable as an integer that indicates how many processes are participating in this barrier operation together.</li>
<li>"realm_rank": the value associated with this key must be interpretable as an integer that uniquely identifies this process in its local group. It must be in the range [0, realm_ranks). Note that each group should have its rank numbering start at zero and grow incrementally. Rank numbers are therefore the same across groups. <a class="el" href="namespaceRealm.html">Realm</a> will generate a unique address space for each process as part of the bootstrap. </li>
</ul>

</div>
</div>
<a id="ad664af62bb1e06c6c421f2969545c056" name="ad664af62bb1e06c6c421f2969545c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad664af62bb1e06c6c421f2969545c056">&#9670;&#160;</a></span>put</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* Realm::Runtime::KeyValueStoreVtable::put) (const void *key, size_t key_size, const void *value, size_t value_sizem, const void *<a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#a8a4e9695f41060b9cae73c3366cb95f9">vtable_data</a>, size_t <a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html#ace5436fe9fcf2f38b0908cd07327d59f">vtable_data_size</a>) = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The "put" function must store a global key value pair in a way that it can be retrieved from any other process using a corresponding get call. The function is passed a buffer containing a key and buffer containing a value. The implementation must copy these values before returning from the callback if it needs to persist them as they are not guaranteed to live longer than the function call. The function should return true if the put succeeds and false if it doesn't. If the call fails then it is likely that the network initialization might not succeed. </p>

</div>
</div>
<a id="a3b0053107b8cf9112c41cc6abad25860" name="a3b0053107b8cf9112c41cc6abad25860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0053107b8cf9112c41cc6abad25860">&#9670;&#160;</a></span>rank_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view Realm::Runtime::KeyValueStoreVtable::rank_key = &quot;realm_rank&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a951c0d5d552550848f57bd0cedcc638d" name="a951c0d5d552550848f57bd0cedcc638d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951c0d5d552550848f57bd0cedcc638d">&#9670;&#160;</a></span>ranks_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view Realm::Runtime::KeyValueStoreVtable::ranks_key = &quot;realm_ranks&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a4e9695f41060b9cae73c3366cb95f9" name="a8a4e9695f41060b9cae73c3366cb95f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4e9695f41060b9cae73c3366cb95f9">&#9670;&#160;</a></span>vtable_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* Realm::Runtime::KeyValueStoreVtable::vtable_data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Optional blob of data passed to all the network vtable functions when they are invoked by <a class="el" href="namespaceRealm.html">Realm</a>. <a class="el" href="namespaceRealm.html">Realm</a> will not attempt to interpret this data at all but will simply pass it through to each call. You do not have to pass any data through to implement the callbacks, it is purely for your convenience. </p>

</div>
</div>
<a id="ace5436fe9fcf2f38b0908cd07327d59f" name="ace5436fe9fcf2f38b0908cd07327d59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5436fe9fcf2f38b0908cd07327d59f">&#9670;&#160;</a></span>vtable_data_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Realm::Runtime::KeyValueStoreVtable::vtable_data_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/realm/realm/realm-src/src/realm/<a class="el" href="runtime_8h_source.html">runtime.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceRealm.html">Realm</a></li><li class="navelem"><a class="el" href="classRealm_1_1Runtime.html">Runtime</a></li><li class="navelem"><a class="el" href="structRealm_1_1Runtime_1_1KeyValueStoreVtable.html">KeyValueStoreVtable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
